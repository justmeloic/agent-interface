# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Root Agent Router Module

This module handles the routing and execution of the root agent's conversation endpoints.
It manages session state purely through ADK's SessionService and handles agent
interactions through FastAPI endpoints.
"""

from typing import Dict, Any, Annotated, Optional
import os
import json
import logging
import uuid
from datetime import datetime, UTC
from pydantic import BaseModel, Field, field_validator
from dotenv import load_dotenv
from fastapi import APIRouter, HTTPException, Depends, Request, Response

# Removed Header from fastapi imports as it's not directly used as a dependency type
# from fastapi.responses import JSONResponse # Not explicitly used
from google.adk.sessions import InMemorySessionService, Session

try:
    from google.adk.sessions import SessionNotFoundError
except ImportError:
    logging.warning(
        "google.adk.sessions.SessionNotFoundError not found, using general Exception for session retrieval errors."
    )
    SessionNotFoundError = Exception  # type: ignore

from google.adk.runners import Runner
from google.genai import types  # Assuming types is correctly imported
from functools import lru_cache
from starlette.middleware.base import BaseHTTPMiddleware, RequestResponseEndpoint
# from starlette.types import Message # Message was not used

# Assuming these are local project imports - replace with actual paths if necessary
from agents.agent import root_agent  # type: ignore
from config import get_settings  # type: ignore

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

# Configure Google Cloud environment
try:
    os.environ["GOOGLE_CLOUD_PROJECT"] = os.getenv("GOOGLE_CLOUD_PROJECT", "")
    os.environ["GOOGLE_CLOUD_LOCATION"] = os.getenv("GOOGLE_CLOUD_LOCATION", "")
    if not all(
        [os.environ["GOOGLE_CLOUD_PROJECT"], os.environ["GOOGLE_CLOUD_LOCATION"]]
    ):
        # Kept original behavior of raising an error.
        # If local testing without these is desired, change to logger.warning.
        raise ValueError(
            "Missing required Google Cloud environment variables: GOOGLE_CLOUD_PROJECT and/or GOOGLE_CLOUD_LOCATION"
        )
except Exception as e:
    logger.error(f"Environment configuration error: {str(e)}")
    raise


# Request model
class Query(BaseModel):
    """Query model for agent requests."""

    text: str = Field(..., min_length=1)

    @field_validator("text")
    @classmethod
    def text_must_not_be_empty(cls, v: str) -> str:
        """Validate that text is not empty or just whitespace."""
        if not v.strip():
            raise ValueError("Text must not be empty or just whitespace")
        return v.strip()


class AgentConfig(BaseModel):
    """Configuration for agent services."""

    app_name: str = Field(default="agent_app")
    user_id: str = Field(default="default_user")


# Global session service to maintain state
_session_service = InMemorySessionService()
# Removed _sessions: Dict[str, Dict[str, Any]] = {} to rely on ADK service


class SessionMiddleware(BaseHTTPMiddleware):
    """
    Middleware to manage a candidate session ID from request headers
    and ensure the actual session ID used is set in the response.
    """

    async def dispatch(
        self, request: Request, call_next: RequestResponseEndpoint
    ) -> Response:
        candidate_session_id = request.headers.get("X-Session-ID")
        if not candidate_session_id:
            candidate_session_id = str(uuid.uuid4())
            logger.info(
                f"No X-Session-ID header. Generated candidate ID: {candidate_session_id}"
            )
        else:
            logger.info(f"Received X-Session-ID header: {candidate_session_id}")

        # Store the initial candidate ID on request.state
        request.state.candidate_session_id = candidate_session_id

        response = await call_next(request)

        # Ensure the actual session ID (which might have been (re)generated by get_or_create_session)
        # is set in the response header.
        if (
            hasattr(request.state, "actual_session_id")
            and request.state.actual_session_id
        ):
            response.headers["X-Session-ID"] = request.state.actual_session_id
        elif (
            "X-Session-ID" not in response.headers
        ):  # Fallback, though get_or_create_session should set it
            response.headers["X-Session-ID"] = candidate_session_id
            logger.warning(
                f"X-Session-ID header was not set by dependencies for candidate {candidate_session_id}; falling back to candidate ID."
            )

        return response


@lru_cache
def get_agent_config() -> AgentConfig:
    """Get agent configuration with caching."""
    settings = get_settings()
    return AgentConfig(
        app_name=settings.get("app_name", "agent_app"),
        user_id=settings.get("user_id", "default_user"),
    )


def get_session_service() -> InMemorySessionService:
    """Dependency for session service."""
    return _session_service


async def get_or_create_session(
    request: Request,
    response: Response,  # FastAPI injects this, allowing header modification
    config: Annotated[AgentConfig, Depends(get_agent_config)],
    session_service: Annotated[InMemorySessionService, Depends(get_session_service)],
) -> Session:
    """
    Gets an existing session or creates a new one using ADK's SessionService.
    Relies on ADK for session state and ensures async methods are awaited.
    The actual session ID used is stored in request.state.actual_session_id
    and set in the 'X-Session-ID' response header.
    """
    candidate_session_id = request.state.candidate_session_id
    actual_session: Optional[Session] = None
    # Start by assuming the candidate ID will be the actual ID,
    # but this will be overridden if a new session is created by the service.
    actual_session_id_to_use = candidate_session_id

    try:
        # Attempt to get the session using the candidate_session_id
        actual_session = await session_service.get_session(  # Must await
            session_id=candidate_session_id, user_id=config.user_id
        )
        logger.info(
            f"Retrieved existing session '{candidate_session_id}' for user '{config.user_id}'. Last update: {datetime.fromtimestamp(actual_session.last_update_time, UTC) if actual_session.last_update_time else 'N/A'}."
        )
        # actual_session_id_to_use remains candidate_session_id as it was found

    except SessionNotFoundError:
        logger.info(
            f"Session '{candidate_session_id}' for user '{config.user_id}' not found. Creating new session."
        )
        # Create a new session, letting the service generate the ID
        actual_session = await session_service.create_session(  # Must await
            app_name=config.app_name,
            user_id=config.user_id,
            # Do NOT pass session_id here; let the service generate it.
        )
        actual_session_id_to_use = (
            actual_session.id
        )  # Use the ID generated by the service
        logger.info(
            f"Created new session with service-generated ID: '{actual_session_id_to_use}' for user '{config.user_id}'."
        )
    except Exception as e:  # Catch other unexpected errors during get_session
        logger.error(
            f"Error during get_session for '{candidate_session_id}' (user: {config.user_id}): {type(e).__name__} - {str(e)}. Attempting to create a new session as fallback."
        )
        try:
            actual_session = await session_service.create_session(  # Must await
                app_name=config.app_name, user_id=config.user_id
            )
            actual_session_id_to_use = actual_session.id
            logger.info(
                f"Fallback: Created new session with service-generated ID: '{actual_session_id_to_use}' for user '{config.user_id}'."
            )
        except Exception as creation_e:  # Fatal if creation also fails
            logger.critical(
                f"CRITICAL: Failed to create a new session after a get_session error: {str(creation_e)}"
            )
            raise HTTPException(
                status_code=500,
                detail={
                    "message": "Failed to initialize session (get and create failed).",
                    "error": str(creation_e),
                },
            )

    if not actual_session:  # Should not be reached if logic above is correct
        logger.critical(
            "CRITICAL: actual_session is None after get_or_create_session logic."
        )
        raise HTTPException(
            status_code=500, detail="Session initialization failed unexpectedly."
        )

    # Ensure the final, actual session ID is on request.state and in response header
    request.state.actual_session_id = actual_session_id_to_use
    response.headers["X-Session-ID"] = actual_session_id_to_use

    return actual_session


def get_runner(
    config: Annotated[AgentConfig, Depends(get_agent_config)],
    session_service: Annotated[InMemorySessionService, Depends(get_session_service)],
) -> Runner:
    """Dependency for runner, ensuring app_name is provided."""
    try:
        return Runner(
            agent=root_agent,
            app_name=config.app_name,  # Ensure app_name is passed
            session_service=session_service,
        )
    except Exception as e:
        logger.error(f"Failed to create runner: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={"message": "Failed to initialize agent runner", "error": str(e)},
        )


router = APIRouter(
    prefix="/root_agent",
    tags=["root_agent"],
)


@router.post("/", response_model=Dict[str, Any])
async def agent_endpoint(
    request: Request,  # Contains request.state.actual_session_id (set by get_or_create_session)
    # response: Response, # No longer needed here, as get_or_create_session handles its headers
    query: Query,
    config: Annotated[AgentConfig, Depends(get_agent_config)],
    session: Annotated[
        Session, Depends(get_or_create_session)
    ],  # This session object has the actual_session_id
    runner: Annotated[Runner, Depends(get_runner)],
) -> Dict[str, Any]:
    """
    Process user queries through the agent.
    Uses the actual_session_id from request.state, which is set by get_or_create_session.
    """
    actual_session_id = request.state.actual_session_id  # Use the finalized session ID

    # Logging the session's last update time from the ADK Session object
    logger.info(
        f"Processing agent query for session '{actual_session_id}' (User: {config.user_id}). Session's last known ADK update: {datetime.fromtimestamp(session.last_update_time, UTC) if session.last_update_time else 'N/A'}."
    )

    try:
        content = types.Content(role="user", parts=[types.Part(text=query.text)])
        final_response_text = "Agent did not produce a final response."
        references_json = {}

        logger.info(
            f"Running agent for session '{actual_session_id}', user '{config.user_id}' with query: '{query.text[:100]}...'"
        )

        async for event in runner.run_async(
            user_id=config.user_id,
            session_id=actual_session_id,  # Pass the actual_session_id
            new_message=content,
        ):
            if event.is_final_response():
                if event.content and event.content.parts:
                    response_text = event.content.parts[0].text
                    if "<START_OF_REFERENCE_DOCUMENTS>" in response_text:
                        parts = response_text.split("<START_OF_REFERENCE_DOCUMENTS>", 1)
                        final_response_text = parts[0].strip()
                        if len(parts) > 1:
                            references_text = parts[1].strip()
                            try:
                                references_list = json.loads(references_text)
                                references_json = {
                                    str(i + 1): {
                                        "title": ref.get("title", ""),
                                        "link": ref.get("link", ""),
                                        "text": ref.get("text", ""),
                                    }
                                    for i, ref in enumerate(references_list)
                                    if isinstance(ref, dict)
                                }
                            except json.JSONDecodeError as e:
                                logger.error(
                                    f"Failed to parse references JSON for session {actual_session_id}: {str(e)}\nContent: {references_text[:200]}"
                                )
                                references_json = {}
                        else:
                            references_json = {}
                    else:
                        final_response_text = response_text.strip()
                        references_json = {}
                elif event.actions and event.actions.escalate:
                    final_response_text = f"Agent escalated: {event.error_message or 'No specific message.'}"
                break

        logger.info(
            f"Successfully processed agent query for session '{actual_session_id}'. Response: '{final_response_text[:100]}...'"
        )
        return {"response": final_response_text, "references": references_json}
    except Exception as e:
        logger.exception(
            f"Error processing agent query for session {actual_session_id}: {str(e)}"
        )
        raise HTTPException(
            status_code=500,
            detail={"message": "Error processing agent query", "error": str(e)},
        )
